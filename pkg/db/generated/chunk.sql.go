// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: chunk.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteChunkByID = `-- name: DeleteChunkByID :exec
DELETE FROM chunks WHERE id = $1
`

func (q *Queries) DeleteChunkByID(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteChunkByID, id)
	return err
}

const deleteChunkNodeMapping = `-- name: DeleteChunkNodeMapping :exec
DELETE FROM chunk_node_locations WHERE chunk_id = $1 AND node_id = $2
`

type DeleteChunkNodeMappingParams struct {
	ChunkID pgtype.UUID
	NodeID  pgtype.UUID
}

func (q *Queries) DeleteChunkNodeMapping(ctx context.Context, arg DeleteChunkNodeMappingParams) error {
	_, err := q.db.Exec(ctx, deleteChunkNodeMapping, arg.ChunkID, arg.NodeID)
	return err
}

const getChunkByID = `-- name: GetChunkByID :one
SELECT id, object_id, chunk_index, chunk_size, chunk_hash FROM chunks WHERE id = $1
`

func (q *Queries) GetChunkByID(ctx context.Context, id pgtype.UUID) (Chunk, error) {
	row := q.db.QueryRow(ctx, getChunkByID, id)
	var i Chunk
	err := row.Scan(
		&i.ID,
		&i.ObjectID,
		&i.ChunkIndex,
		&i.ChunkSize,
		&i.ChunkHash,
	)
	return i, err
}

const getChunksByHash = `-- name: GetChunksByHash :many
SELECT id, object_id, chunk_index, chunk_size, chunk_hash FROM chunks WHERE chunk_hash = $1
`

func (q *Queries) GetChunksByHash(ctx context.Context, chunkHash string) ([]Chunk, error) {
	rows, err := q.db.Query(ctx, getChunksByHash, chunkHash)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Chunk
	for rows.Next() {
		var i Chunk
		if err := rows.Scan(
			&i.ID,
			&i.ObjectID,
			&i.ChunkIndex,
			&i.ChunkSize,
			&i.ChunkHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChunksByObjectID = `-- name: GetChunksByObjectID :many
SELECT id, object_id, chunk_index, chunk_size, chunk_hash FROM chunks WHERE object_id = $1 ORDER BY chunk_index
`

func (q *Queries) GetChunksByObjectID(ctx context.Context, objectID pgtype.UUID) ([]Chunk, error) {
	rows, err := q.db.Query(ctx, getChunksByObjectID, objectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Chunk
	for rows.Next() {
		var i Chunk
		if err := rows.Scan(
			&i.ID,
			&i.ObjectID,
			&i.ChunkIndex,
			&i.ChunkSize,
			&i.ChunkHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChunksOnNode = `-- name: GetChunksOnNode :many
SELECT c.id, c.object_id, c.chunk_index, c.chunk_size, c.chunk_hash
FROM chunks c
JOIN chunk_node_locations cnl ON c.id = cnl.chunk_id
WHERE cnl.node_id = $1
`

func (q *Queries) GetChunksOnNode(ctx context.Context, nodeID pgtype.UUID) ([]Chunk, error) {
	rows, err := q.db.Query(ctx, getChunksOnNode, nodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Chunk
	for rows.Next() {
		var i Chunk
		if err := rows.Scan(
			&i.ID,
			&i.ObjectID,
			&i.ChunkIndex,
			&i.ChunkSize,
			&i.ChunkHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNodesForChunk = `-- name: GetNodesForChunk :many
SELECT n.id, n.address, n.grpc_address, n.hostname, n.last_seen, n.is_healthy, n.total_space, n.free_space, n.readonly, n.controller_master_id
FROM nodes n
JOIN chunk_node_locations cnl ON n.id = cnl.node_id
WHERE cnl.chunk_id = $1
`

func (q *Queries) GetNodesForChunk(ctx context.Context, chunkID pgtype.UUID) ([]Node, error) {
	rows, err := q.db.Query(ctx, getNodesForChunk, chunkID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Node
	for rows.Next() {
		var i Node
		if err := rows.Scan(
			&i.ID,
			&i.Address,
			&i.GrpcAddress,
			&i.Hostname,
			&i.LastSeen,
			&i.IsHealthy,
			&i.TotalSpace,
			&i.FreeSpace,
			&i.Readonly,
			&i.ControllerMasterID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertChunk = `-- name: InsertChunk :exec
INSERT INTO chunks (id, chunk_index, chunk_hash)
VALUES ($1, $2, $3)
`

type InsertChunkParams struct {
	ID         pgtype.UUID
	ChunkIndex int32
	ChunkHash  string
}

func (q *Queries) InsertChunk(ctx context.Context, arg InsertChunkParams) error {
	_, err := q.db.Exec(ctx, insertChunk, arg.ID, arg.ChunkIndex, arg.ChunkHash)
	return err
}

const insertChunkNodeMapping = `-- name: InsertChunkNodeMapping :exec
INSERT INTO chunk_node_locations (chunk_id, node_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type InsertChunkNodeMappingParams struct {
	ChunkID pgtype.UUID
	NodeID  pgtype.UUID
}

func (q *Queries) InsertChunkNodeMapping(ctx context.Context, arg InsertChunkNodeMappingParams) error {
	_, err := q.db.Exec(ctx, insertChunkNodeMapping, arg.ChunkID, arg.NodeID)
	return err
}

const upsertChunk = `-- name: UpsertChunk :exec
INSERT INTO chunks (id, chunk_index, chunk_hash)
VALUES ($1, $2, $3)
ON CONFLICT (id)
DO UPDATE SET chunk_index = EXCLUDED.chunk_index, chunk_hash = EXCLUDED.chunk_hash
`

type UpsertChunkParams struct {
	ID         pgtype.UUID
	ChunkIndex int32
	ChunkHash  string
}

func (q *Queries) UpsertChunk(ctx context.Context, arg UpsertChunkParams) error {
	_, err := q.db.Exec(ctx, upsertChunk, arg.ID, arg.ChunkIndex, arg.ChunkHash)
	return err
}
